# -*- coding: utf-8 -*-
"""Stock_market_analysis_and_price_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iChX9EG5xAtWEGlY2LnQHcITnHVDlHuQ

**Dataset Extraction:**
"""

# Installation of yfinance library.
!pip install yfinance

import yfinance as yf
import pandas as pd
from datetime import datetime

# Downloading the Infosys Stocks
data = yf.download('INFY.NS')

#To save file in csv format
data.to_csv('INFY.csv')

"""Data Dictionary:

Open : Opening price or starting price of stock at that particular date.

Close : Closing price or ending price of stock at that particular date.

High : The highest price at which the stock was traded during the trading day.

Low : The lowest price at which the stock was traded during the trading day.

Adj Close : The adjusted close price is the closing price of the stock after adjustments have been made for actions such as dividends, stock splits, or new stock issuance.

Volume : Volume represents the total number of shares of the stock that were traded during the trading day.
"""

df=pd.read_csv('/content/INFY.csv')
df.head()

#Minimum date or starting date from whole dataset.
df['Date'].min()

#Maximum date or ending date from whole dataset.
df['Date'].max()

# Filter the DataFrame for the date range
df = df[(df['Date'] >= '2010-01-01') & (df['Date'] <= '2015-01-01')]

#Column name     Datatype  Description:

# Date          Date      Date it belong particular day
# Open          Float     Open depends market starting rate
# High          Float     High depends peak of the day
# Low           Float     Low belongs lowest value on the day
# Adj Close     Init      Adj close is more accurate indicator
# Volume        Float     Volume is how many shares on that day

df.describe().T

#To show only first five data.
df.head()

# Save the DataFrame to a CSV file
csv_path = '/content/infy.csv'
df.to_csv(csv_path, index=False)

"""**Reading the formatted stock:**"""

df=pd.read_csv('/content/infy.csv')

"""**Explanatory Data Analysis (EDA):**"""

# Convert the 'Date' column to datetime format if it is not already
df['Date'] = pd.to_datetime(df['Date'])
df.head()

df.tail()

df.describe().T

df.info()

# for checking missing values
# There are no missing values
df.isnull().sum()

# Importing necessary libraries:
import matplotlib.pyplot as plt
import seaborn as sns

"""Closing Price

The closing price is the last price at which the stock is traded during the regular trading day. A stock’s closing price is the standard benchmark used by investors to track its performance over time.
"""

# Line chart of closing stock price over time
plt.figure(figsize=(10, 6))
sns.lineplot(x='Date', y='Adj Close', data=df)
plt.title('Closing Stock Price Over Time')
plt.xlabel('Date')
plt.ylabel('Closing Stock Price')
plt.show()

"""Volume of Sales

Volume is the amount of an asset or security that changes hands over some period of time, often over the course of a day. For instance, the stock trading volume would refer to the number of shares of security traded between its daily open and close. Trading volume, and changes to volume over the course of time, are important inputs for technical traders.
"""

# Line chart of volume of sales
plt.figure(figsize=(10, 6))
sns.lineplot(x='Date', y='Volume', data=df)
plt.title('Sales Volume for INFY')
plt.xlabel('Date')
plt.ylabel('Volume in 10crores')
plt.show()

"""Moving average of the various stocks.

The moving average (MA) is a simple technical analysis tool that smooths out price data by creating a constantly updated average price. The average is taken over a specific period of time, like 10 days, 20 minutes, 30 weeks, or any time period the trader chooses.

Advantages of Moving Averages:

Technical Analysis:Moving Averages help traders and investors understand the market's direction and make informed decisions based on price patterns.

Trend Confirmation: They confirm trends when prices consistently stay above or below certain moving averages.

Market Sentiment: Moving averages reflect overall market sentiment. A rising MA indicates bullish sentiment, while a falling MA indicates bearish sentiment.
"""

# Calculating the 20-day and 50-day moving averages directly on fdf
df['20 Day MA'] = df['Adj Close'].rolling(window=20).mean()
df['50 Day MA'] = df['Adj Close'].rolling(window=50).mean()

# Plot the Adjusted Closing Price and Moving Averages
plt.figure(figsize=(14, 7))
plt.plot(df['Date'], df['Adj Close'], label='Adjusted Close Price', color='blue')
plt.plot(df['Date'], df['20 Day MA'], label='20 Day Moving Average', color='red')
plt.plot(df['Date'], df['50 Day MA'], label='50 Day Moving Average', color='green')
plt.title('Infosys Stock Price and Moving Averages')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

# Calculate daily returns
df['Daily_Return'] = df['Adj Close'].pct_change()

# Plotting the daily returns
plt.figure(figsize=(14, 7))
plt.plot(df['Date'], df['Daily_Return'], label='Daily Return', color='blue')

# Adding labels and title
plt.title('Daily Returns')
plt.xlabel('Date')
plt.ylabel(' Daily Return (%) ')
plt.legend()

# Rotate date labels for better readability
plt.xticks(rotation=45)

# Show the plot
plt.show()

# Price distribution of closing price
plt.figure(figsize=(10, 6))
plt.hist(df['Adj Close'], bins=10, color='blue', edgecolor='black', alpha=0.7)
plt.title('Distribution of Closing Prices')
plt.xlabel('Closing Price')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

"""Here we are calculating the daily returns of the stock based on the adjusted closing prices.

df['Adj Close']: This is the column in the DataFrame df that contains the adjusted closing prices for each day.

<.pct_change()>: This function calculates the percentage change between the current adjusted closing price and the previous day adjusted closing price. The result is stored in a new column 'Daily Return' in fdf.

Daily return: Daily return is a measure that shows how much the price of a stock has changed from one day to the next, expressed as a percentage.

The daily return for a given day is calculated using the formula:

Daily Return = [(Price today - Price yesterday) / Price yesterday] * 100

Decompose the data for better visualization which contains trend , seasonality ,residual.

Trend Component: The overall direction of the data (long-term increase or decrease). Seasonal Component: The repeating short-term cycle (e.g., yearly, monthly). Residual Component: The remainder of the data after removing trend and seasonality (often considered noise).
"""

# Fill the missing values (if any )with forward_fill
df["Adj Close"]=df["Adj Close"].ffill()

# Ensure there is no NAN values in "Close" Column
df["Adj Close"]=pd.to_numeric(df["Adj Close"],errors="coerce")

# Drop th remaining null values
df=df.dropna(subset=["Adj Close"])

# Installing the required libraries
#!pip install statsmodels
from matplotlib import pyplot as plt

# Import the seasonal_decompose from statsmodels
from statsmodels.tsa.seasonal import seasonal_decompose

# Perform seasonal decompostion with an appropriate period for this dataset
# Assuming daily data with yearly seasonality (period = 252 for trading days , excluding weekends and holidays).
model = seasonal_decompose(df["Adj Close"],model="multiplicative",period=252)

# plot the decompose components
Trend=model.trend
Seasonal=model.seasonal
Residual=model.resid

# Define the figure size

# plot the Trend
plt.figure(figsize=(8,6))
plt.plot(Trend,label="Trend",color="red")
plt.legend(loc="best") # Add legend with loc='best'to place the legend in a fixed location
plt.xticks(rotation=45)

# plot seasonal component
plt.figure(figsize=(8,6))
plt.plot(Seasonal,label="Seasonal",color="green")
plt.legend(loc='best')
plt.xticks(rotation=45)

# plot Residual component
plt.figure(figsize=(8,6))
plt.plot(Residual,label="Residual",color="blue")
plt.legend(loc='best')
plt.xticks(rotation=45)

from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout
from sklearn.metrics import mean_squared_error

from statsmodels.tsa.stattools import adfuller
import warnings

"""**ARIMA**"""

df_ar=pd.read_csv('/content/infy.csv')

df_ar.columns

df_ar['Date'] = pd.to_datetime(df_ar['Date'])

df_ar.info()

#Augmented Dickey–Fuller test for stationarity:

print('Results of Dickey Fuller Test:')

result = adfuller(df_ar['Adj Close'])
# Output the results
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
plot_acf(df_ar['Adj Close'])
plt.show()
plot_pacf(df_ar['Adj Close'])
plt.show()

# Set 'Date' as the index of the DataFrame
df_ar.set_index('Date', inplace=True)

!pip install statsmodels
from statsmodels.tsa.arima.model import ARIMA  # Import the ARIMA class

# ... (your other code) ...

model_arima = ARIMA(df_ar['Adj Close'], order=(1, 1, 1))
model_arima_fit = model_arima.fit()
model_arima_fit.summary()

model_arima = ARIMA(df_ar['Adj Close'], order=(1,1,1))
model_arima_fit = model_arima.fit()
model_arima_fit.summary()

#AIC arima model example, changing d value it shows aic value maybe changed
arima = ARIMA(df_ar['Adj Close'], order=(1,1,1))
predicted = arima.fit()
predicted.summary()
df_ar['arima'] = predicted.fittedvalues

forecast_steps = 20 # Number of steps to forecast
arima_forecast = predicted .get_forecast(steps=forecast_steps)
df_ar_forecast = arima_forecast.predicted_mean

# Combine both in-sample and out-of-sample predictions
df_ar = df_ar.copy()
df_ar = pd.concat([df_ar, df_ar_forecast], axis=1)

df_ar_forecast

plt.figure(figsize=(12, 8))
plt.plot(df_ar.index, df_ar['Adj Close'], label='Original', color='orange')
plt.plot(df_ar.index, df_ar['arima'], color='green',linestyle='--', label='ARIMA Fitted')\
# Limiting the x-axis to focus on the 2010-2015 period
plt.xlim(pd.to_datetime('2010-01-01'), pd.to_datetime('2015-01-01'))
plt.title('ARIMA Forecast (2010-2015)')
plt.legend()
plt.show()

from sklearn.metrics import mean_squared_error
import numpy as np
# Drop rows where either 'Adj Close' or 'arima' has NaN values
df_ar_evaluate = df_ar[['Adj Close', 'arima']].dropna()

# Now calculate MSE and RMSE
mse_arima = mean_squared_error(df_ar_evaluate['Adj Close'], df_ar_evaluate['arima'])
rmse_arima = np.sqrt(mse_arima)

print(f"ARIMA Model - MSE: {mse_arima}, RMSE: {rmse_arima}")

# Import the necessary class
from statsmodels.tsa.statespace.sarimax import SARIMAX

#model fitting sarimax
sarima = SARIMAX(df_ar['Adj Close'],
                order=(1,1,1),
                seasonal_order=(1,1,1,12))
predicted=sarima.fit()
df_ar['sarima'] = predicted.fittedvalues

#model fitting sarimax

sarima = SARIMAX(df_ar['Adj Close'],
                order=(1,1,1),
                seasonal_order=(1,1,1,12))
predicted=sarima.fit()
df_ar['sarima'] = predicted.fittedvalues

forecast_steps = 12 # Number of steps to forecast
sarima_forecast = predicted .get_forecast(steps=forecast_steps)
df_ar_forecast = sarima_forecast.predicted_mean

# Combine both in-sample and out-of-sample predictions
df_ar = df_ar.copy()
df_ar = pd.concat([df_ar, df_ar_forecast], axis=1)

plt.figure(figsize=(12, 8))
plt.plot(df_ar.index, df_ar['Adj Close'], label='Original', color='orange')
plt.plot(df_ar.index, df_ar['sarima'], color='green',linestyle='--', label='SARIMA Fitted')
# Limiting the x-axis to focus on the 2010-2015 period
plt.xlim(pd.to_datetime('2010-01-01'), pd.to_datetime('2015-01-01'))
plt.title("SARIMA Forecast")
plt.legend()
plt.show()

# Drop rows where either 'Adj Close' or 'sarima' has NaN values
df_sarima_evaluate = df_ar[['Adj Close', 'sarima']].dropna()

# Now calculate MSE and RMSE for SARIMA
mse_sarima = mean_squared_error(df_sarima_evaluate['Adj Close'], df_sarima_evaluate['sarima'])
rmse_sarima = np.sqrt(mse_sarima)

print(f"SARIMA Model - MSE: {mse_sarima}, RMSE: {rmse_sarima}")

"""**Linear Regression**"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt

# dropping the date index columns and making it an independent column again:
df = df.reset_index()


# Convert 'Date' to numerical format (e.g., the number of days since the first date in the dataset)
df['Date_ordinal'] = df['Date'].map(pd.Timestamp.toordinal)

# Define X and y
X = df[['Date_ordinal']]  # Independent variable
y = df['Close']           # Target variable

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and train the linear regression model
lr_model = LinearRegression()
lr_model.fit(X_train, y_train)

# Predict using the test set
y_pred = lr_model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f'Mean Squared Error: {mse}')
print(f'R^2 Score: {r2}')

# Convert the ordinal date back to datetime for better understanding in the plot
X_test_dates = X_test['Date_ordinal'].map(pd.Timestamp.fromordinal)
X_train_dates = X_train['Date_ordinal'].map(pd.Timestamp.fromordinal)

# Plot the results with proper date labels
plt.figure(figsize=(10,6))
plt.scatter(X_test_dates, y_test, color='blue', label='Actual')
plt.plot(X_test_dates, y_pred, color='red', label='Predicted', linewidth=2)
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.title('Linear Regression Prediction of Stock Closing Prices')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.legend()
plt.tight_layout()
plt.show()

"""**LSTM Model For stock price prediction:**"""

from datetime import datetime
stock = "INFY.NS"
end = datetime.now()
start = datetime(end.year-20, end.month, end.day)
infy_data = yf.download(stock, start, end)

infy_data.head()

infy_data.tail()

infy_data.info()

infy_data.columns

infy_data.index

infy_data.describe()

infy_data.isnull().sum() # There are no missing values

def plot_graph(figsize, values, column_name):
     plt.figure()
     values.plot(figsize = figsize)
     plt.xlabel("Years")
     plt.ylabel(column_name)
     plt.title(f"{column_name} of Infosys Data")

infy_data.columns

for column in infy_data.columns:
  plot_graph((15,7),infy_data[column],column)

# Calculating the 50-day moving averages
infy_data['50 Day MA'] = infy_data['Adj Close'].rolling(window=50).mean()

# Plot the Adjusted Closing Price and Moving Averages
plt.figure(figsize=(20, 7))
plt.plot(infy_data.index, infy_data['Adj Close'], label='Adjusted Close Price', color='green')
plt.plot(infy_data.index, infy_data['50 Day MA'], label='50 Day Moving Average', color='red', linestyle='--')
plt.title('Infosys Stock Price and 50 Day Moving Averages')
plt.xlabel('Years')
plt.ylabel('Price')
plt.legend()
plt.show()

# Calculating the 250-day moving averages
infy_data['250 Day MA'] = infy_data['Adj Close'].rolling(window=250).mean()

# Plot the Adjusted Closing Price and Moving Averages
plt.figure(figsize=(20, 7))
plt.plot(infy_data.index, infy_data['Adj Close'], label='Adjusted Close Price', color='green')
plt.plot(infy_data.index, infy_data['250 Day MA'], label='250 Day Moving Average', color='red', linestyle='--')
plt.title('Infosys Stock Price and 250 Day Moving Averages')
plt.xlabel('Years')
plt.ylabel('Price')
plt.legend()
plt.show()

plt.figure(figsize=(20, 7))
plt.plot(infy_data.index, infy_data['Adj Close'], label='Adjusted Close Price', color='blue')
plt.plot(infy_data.index, infy_data['50 Day MA'], label='50 Day Moving Average',color='red')
plt.plot(infy_data.index, infy_data['250 Day MA'], label='250 Day Moving Average', color='green')
plt.title('Infosys Stock Price and Moving Averages')
plt.xlabel('Years')
plt.ylabel('Price')
plt.legend()
plt.show()

# Calculate daily returns for 20 years
infy_data['Daily_Return_in_percentage'] = infy_data['Adj Close'].pct_change()
infy_data[['Adj Close','Daily_Return_in_percentage']].head()

#Plot of Daily returns for 20 years
plot_graph((20,7), infy_data['Daily_Return_in_percentage'], 'Percentage Change')

#Histogram for numerical variables to show skewness.
infy_data['Daily_Return_in_percentage'].hist(bins=20, figsize=(7, 5))
plt.suptitle('Daily Return of Infosys Stock')
plt.tight_layout()

"""**LSTM model**"""

pip install pandas_ta

Adj_close_price = infy_data[['Adj Close']]

max(Adj_close_price.values),min(Adj_close_price.values)

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range=(0,1))
scaled_infy_data = scaler.fit_transform(Adj_close_price)
scaled_infy_data

len(scaled_infy_data)

import numpy as np

x_infy_data = []
y_infy_data = []

for i in range(100, len(scaled_infy_data)):
    x_infy_data.append(scaled_infy_data[i-100:i])
    y_infy_data.append(scaled_infy_data[i])

x_infy_data, y_infy_data = np.array(x_infy_data), np.array(y_infy_data)

x_infy_data[0],y_infy_data[0]

int(len(x_infy_data)*0.7)

infy_data.shape

4938-100-int(len(x_infy_data)*0.7) #!!!!!!!!!!!!!!!!!

splitting_len = int(len(x_infy_data)*0.7)
x_infy_train = x_infy_data[:splitting_len]
y_infy_train = y_infy_data[:splitting_len]

x_infy_test = x_infy_data[splitting_len:]
y_infy_test = y_infy_data[splitting_len:]

print(x_infy_train.shape)
print(y_infy_train.shape)
print(x_infy_test.shape)
print(y_infy_test.shape)

from keras.models import Sequential
from keras.layers import Dense, LSTM

lstm_model = Sequential()
lstm_model.add(LSTM(128, return_sequences=True, input_shape=(x_infy_train.shape[1],1)))
lstm_model.add(LSTM(64,return_sequences=False))
lstm_model.add(Dense(25))
lstm_model.add(Dense(1))

lstm_model.compile(optimizer='adam', loss='mean_squared_error')

lstm_model.fit(x_infy_train, y_infy_train, batch_size=15, epochs=30,shuffle=True, validation_split = 0.1)

lstm_model.summary()

predictions = lstm_model.predict(x_infy_test)

predictions

inv_predictions = scaler.inverse_transform(predictions)
inv_predictions

inv_y_infy_test = scaler.inverse_transform(y_infy_test)
inv_y_infy_test

rmse=np.sqrt(np.mean( (inv_predictions - inv_y_infy_test)**2))
print(f'RMSE:{rmse}')

ploting_data = pd.DataFrame(
 {
  'original_test_data': inv_y_infy_test.reshape(-1),
    'predictions': inv_predictions.reshape(-1)
 } ,
    index = infy_data.index[splitting_len+100:]
)
ploting_data.head()

plot_graph((15,6), ploting_data, 'Test data')

#plot_graph((15,6), pd.concat([Adj_close_price[:splitting_len+100],ploting_data], axis=0))
plot_graph((15,6), pd.concat([Adj_close_price[:splitting_len+100],ploting_data], axis=0), 'Combined data')

lstm_model.save("stock_price_lstm_model.keras")